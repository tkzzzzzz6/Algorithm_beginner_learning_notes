### 题目解析

你有一个 \( n \times m \) 的 01 矩阵，可以进行如下三种操作之一：
1. 选择两行（可以相同），依次反转这两行。
2. 选择两列（可以相同），依次反转这两列。
3. 选择一行和一列，依次反转这一行和这一列（交点反转两次，相当于没变）。

问：能否通过一次这样的操作把矩阵变成全0？

---

### 结论与思路

**核心结论：**
- 只要矩阵中所有的 1 的个数是偶数，就一定可以通过上述操作变成全0。
- 如果 1 的个数是奇数，则无论怎么操作都无法全变成0。

**原因分析：**
- 每次操作（无论选行还是列）都会改变若干个格子的状态，每个格子被反转的次数要么是0、1、2次。
- 只要 1 的个数是偶数，就可以通过选合适的行/列，使得所有1都被反转为0。
- 具体来说，任选一行或一列，把所有1都反转一次，剩下的再用第二次操作补齐即可。

---

### 代码实现

只需要统计每组数据中1的个数，判断奇偶即可。

```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

int main() {
    int T;
    cin >> T;
    while (T--) {
        int n, m;
        cin >> n >> m;
        int cnt = 0;
        for (int i = 0; i < n; ++i) {
            string row;
            cin >> row;
            for (char c : row) {
                if (c == '1') cnt++;
            }
        }
        if (cnt % 2 == 0)
            cout << "YES" << endl;
        else
            cout << "NO" << endl;
    }
    return 0;
}
```

---

### 总结

- 只需统计所有1的个数，偶数输出YES，奇数输出NO。
- 复杂度 \(O(n \times m)\)，完全可以通过本题数据范围。

如需更快的输入方式，可用 `scanf` 或 `getchar` 优化，但核心思路不变。  
如有疑问欢迎继续追问！
