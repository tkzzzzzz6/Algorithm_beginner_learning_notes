# 质数筛法详解

## 一、函数命名建议

### 1. 基于筛法名称
- `eulerSieve()` / `euler_sieve()` - 欧拉筛
- `eratosthenesSieve()` / `eratosthenes_sieve()` - 埃拉托斯特尼筛
- `linearSieve()` / `linear_sieve()` - 线性筛（欧拉筛的别名）

### 2. 基于功能描述
- `sievePrimes()` / `sieve_primes()` - 筛质数
- `generatePrimes()` / `generate_primes()` - 生成质数
- `getPrimes()` / `get_primes()` - 获取质数

### 3. 组合命名（推荐）
- `eulerSievePrimes()` / `euler_sieve_primes()`
- `eratosthenesSievePrimes()` / `eratosthenes_sieve_primes()`

---

## 二、埃拉托斯特尼筛法（Eratosthenes Sieve）

### 核心思想

**基本思路**：从2开始，将每个质数的所有倍数标记为合数。

### 算法步骤

1. 创建一个布尔数组 `isPrime[]`，初始全部为 `true`
2. 从2开始遍历到n
3. 如果当前数 `i` 是质数（`isPrime[i] == true`）：
   - 将 `i` 加入质数列表
   - 标记 `i` 的所有倍数（`i, 2i, 3i, ...`）为合数
4. 优化：标记倍数时从 `i*i` 开始（因为 `i*(i-1)` 之前的已经被更小的质数标记过）

### 时间复杂度

- **理论复杂度**：O(n log log n)
- **实际表现**：对于 n = 10^6，大约需要 0.1-0.2 秒

### 空间复杂度

O(n)

### 关键代码

```cpp
for (int i = 2; i <= n; i++) {
    if (isPrime[i]) {
        primes.push_back(i);
        // 从 i*i 开始标记，优化效率
        for (int j = i * i; j <= n; j += i) {
            isPrime[j] = false;
        }
    }
}
```

### 缺点

**每个合数可能被标记多次**：
- 例如：6 会被 2 标记一次，也会被 3 标记一次
- 12 会被 2、3 各标记一次
- 这导致了 O(n log log n) 的时间复杂度

### 示例演示（n=20）

```
初始状态：所有数标记为质数
2: 标记 4,6,8,10,12,14,16,18,20 为合数
3: 标记 9,12,15,18 为合数（6已被2标记）
5: 标记 25（超出范围）
7: 标记 49（超出范围）
...
结果：质数有 2,3,5,7,11,13,17,19
```

---

## 三、欧拉筛（Euler Sieve / Linear Sieve）

### 核心思想

**关键优化**：每个合数**只被它的最小质因数筛掉一次**，实现线性时间复杂度。

### 算法步骤

1. 创建一个布尔数组 `isPrime[]`，初始全部为 `true`
2. 创建一个质数列表 `primes[]`
3. 从2开始遍历到n：
   - 如果 `i` 是质数，加入 `primes[]`
   - 用已知的质数 `primes[j]` 去筛 `i * primes[j]`
   - **关键**：当 `i % primes[j] == 0` 时停止

### 时间复杂度

- **理论复杂度**：O(n) - **线性时间复杂度**
- **实际表现**：对于 n = 10^6，大约需要 0.05-0.1 秒（比埃筛快约2倍）

### 空间复杂度

O(n)

### 关键代码

```cpp
for (int i = 2; i <= n; i++) {
    if (isPrime[i]) {
        primes.push_back(i);
    }
    
    for (int j = 0; j < primes.size() && primes[j] * i <= n; j++) {
        isPrime[primes[j] * i] = false;
        // 关键：保证每个合数只被最小质因数筛一次
        if (i % primes[j] == 0) {
            break;
        }
    }
}
```

### 为什么 `i % primes[j] == 0` 时要停止？

**核心原理**：保证每个合数只被它的**最小质因数**筛掉。

#### 证明

假设 `i % primes[j] == 0`，即 `i = k * primes[j]`（k是某个整数）

如果继续用 `primes[j+1]` 去筛 `i * primes[j+1]`：
- `i * primes[j+1] = k * primes[j] * primes[j+1]`
- 这个数的最小质因数是 `primes[j]`，而不是 `primes[j+1]`
- 所以应该用 `primes[j]` 在 `i' = k * primes[j+1]` 时筛掉，而不是现在

#### 示例

以筛 12 为例：
- `i = 4, primes[j] = 2`：筛掉 `4 * 2 = 8`
- `i = 4, primes[j] = 3`：筛掉 `4 * 3 = 12` ✓（12的最小质因数是2，但这里用3筛了）
- 如果继续：`i = 4, primes[j] = 5`：会筛掉 `4 * 5 = 20`

**问题**：12 应该被 `i=6, primes[j]=2` 时筛掉（因为 `6 * 2 = 12`，2是12的最小质因数）

**正确做法**：
- `i = 4, primes[j] = 2`：筛掉 `4 * 2 = 8`，然后 `4 % 2 == 0`，**停止**
- `i = 6, primes[j] = 2`：筛掉 `6 * 2 = 12` ✓（用最小质因数2筛）

### 示例演示（n=20）

```
i=2: primes=[2], 筛掉 2*2=4
i=3: primes=[2,3], 筛掉 3*2=6, 3*3=9
i=4: primes=[2,3], 筛掉 4*2=8, 4%2==0停止（不筛4*3=12）
i=5: primes=[2,3,5], 筛掉 5*2=10, 5*3=15, 5*5=25(超出)
i=6: primes=[2,3,5], 筛掉 6*2=12, 6%2==0停止（不筛6*3=18）
i=7: primes=[2,3,5,7], 筛掉 7*2=14, 7*3=21(超出)
...
```

**观察**：
- 12 只被 `i=6, primes[j]=2` 筛一次 ✓
- 18 只被 `i=9, primes[j]=2` 筛一次 ✓（因为 `9*2=18`，2是18的最小质因数）

---

## 四、两种筛法对比

| 特性 | 埃拉托斯特尼筛 | 欧拉筛（线性筛） |
|------|---------------|-----------------|
| **时间复杂度** | O(n log log n) | **O(n)** |
| **空间复杂度** | O(n) | O(n) |
| **每个合数被标记次数** | 多次 | **1次** |
| **代码复杂度** | 简单 | 稍复杂 |
| **适用场景** | 小规模数据 | **大规模数据** |
| **实际速度** | 较慢 | **更快** |

---

## 五、选择建议

### 使用埃拉托斯特尼筛的情况：
- 数据规模较小（n < 10^6）
- 代码要求简单易懂
- 不需要最优性能

### 使用欧拉筛的情况：
- 数据规模较大（n >= 10^6）
- 需要最优性能
- 需要线性时间复杂度保证

---

## 六、实际应用示例

### 统计区间质数个数

```cpp
// 使用欧拉筛预处理
vector<int> primes = eulerSieve(MAXN);
vector<int> prefixSum(MAXN + 1, 0);

// 构建前缀和
for (int i = 2; i <= MAXN; i++) {
    prefixSum[i] = prefixSum[i-1] + (isPrime[i] ? 1 : 0);
}

// 查询 [l, r] 区间质数个数
int query(int l, int r) {
    return prefixSum[r] - prefixSum[l-1];
}
```

---

## 七、总结

1. **埃拉托斯特尼筛**：简单直观，但效率较低
2. **欧拉筛**：复杂一些，但效率最高（线性时间）
3. **推荐**：在竞赛和实际应用中，优先使用**欧拉筛**
