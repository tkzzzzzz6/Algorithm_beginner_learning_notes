#include <bits/stdc++.h>
using namespace std;

/**
 * 题目思路：挡住洪水问题
 * 核心算法：DFS/BFS 边界淹没法
 * 
 * 问题描述：给定一个 n×m 的网格，'0' 表示空地，'*' 表示墙
 * 洪水从边界开始蔓延，遇到墙会被挡住
 * 求最少需要在多少个空地上建墙，才能阻止洪水蔓延到整个区域
 * 
 * 解题思路：
 * 1. 从四条边界开始，对所有能被洪水淹没的 '0' 进行标记（变成 '*'）
 * 2. 剩余未被标记的 '0' 就是需要建墙的位置（因为它们无法被边界洪水直接淹没）
 * 3. 统计内部（去除边界）剩余的 '0' 数量即为答案
 */

/**
 * DFS 函数：模拟洪水从某个位置向四周蔓延
 * @param grid 网格地图
 * @param x 当前位置的行坐标
 * @param y 当前位置的列坐标
 * 
 * 函数逻辑：
 * - 边界条件：越界或遇到墙（'*'）则返回
 * - 递归处理：将当前 '0' 标记为 '*'（表示被洪水淹没），然后向上下左右四个方向继续蔓延
 */
void bfs(vector<string>& grid, int x, int y)
{
    int n = grid.size();      // 网格行数
    int m = grid[0].size();   // 网格列数
    
    // 边界检查：越界或遇到墙则停止蔓延
    if (x < 0 || x >= n || y < 0 || y >= m || grid[x][y] == '*')
    {
        return;
    }
    
    // 将当前空地标记为墙（表示被洪水淹没）
    grid[x][y] = '*';
    
    // 向四个方向递归蔓延（上、左、下、右）
    bfs(grid, x-1, y);  // 上
    bfs(grid, x, y-1);  // 左
    bfs(grid, x+1, y);  // 下
    bfs(grid, x, y+1);  // 右
}

int main() {
    // 读取网格的行数 n 和列数 m
    int n, m;
    cin >> n >> m;
    
    // 创建 n×m 的字符串数组，存储网格地图
    vector<string> grid(n);
    for (int i = 0; i < n; ++i)
        cin >> grid[i];

    // ========== 第一步：从四条边界开始淹没 ==========
    // 处理左右边界（第一列和最后一列）
    for (int i = 0; i < n; ++i)
    {
        // 左边界：如果第一列的位置是空地 '0'，则从该位置开始淹没
        if (grid[i][0] == '0')
        {
            bfs(grid, i, 0);
        }
        // 右边界：如果最后一列的位置是空地 '0'，则从该位置开始淹没
        if (grid[i][m-1] == '0')
        {
            bfs(grid, i, m-1);
        }
    }

    // 处理上下边界（第一行和最后一行）
    // 注意：j 从 1 到 m-2，避免重复处理四个角的位置
    for (int j = 1; j < m-1; ++j)
    {
        // 上边界：如果第一行的位置是空地 '0'，则从该位置开始淹没
        if (grid[0][j] == '0')
        {
            bfs(grid, 0, j);
        }
        // 下边界：如果最后一行的位置是空地 '0'，则从该位置开始淹没
        if (grid[n-1][j] == '0')
        {
            bfs(grid, n-1, j);
        }
    }
    
    // ========== 第二步：统计内部剩余的空地数量 ==========
    // 经过边界淹没后，内部剩余的 '0' 就是需要建墙的位置
    int ans = 0;
    for (int i = 1; i < n-1; ++i)      // 只统计内部区域（不包括边界）
    {
        for (int j = 1; j < m-1; ++j)
        {
            if (grid[i][j] == '0')      // 如果该位置仍是空地
            {
                ans++;                   // 计数加一
            }
        }
    }
    
    // 输出答案
    cout << ans;
}
