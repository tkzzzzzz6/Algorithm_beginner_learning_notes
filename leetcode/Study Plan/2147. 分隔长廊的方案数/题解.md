# 2147. 分隔长廊的方案数 — 题解

## 思路概述

- 长廊由 `S`(seat) 和 `P`(plant) 组成，需要用隔板分成若干段，每段恰有 **2 个座位**。
- 扫描字符串统计座位：
  - 第 1、2 个座位确定了第一段的左右边界；
  - 当遇到第 3、5、7… 个座位（即 `cnt_s >= 3` 且为奇数）时，说明前一段已完成、当前座位是下一段的起点。
  - 隔板可放在“上一段最后一个座位”和“当前座位”之间的任意空隙，贡献因子为 `i - last_s`（两座位下标差）。
  - 将贡献累乘进答案（取模 1e9+7）。
- 扫描结束后，若座位总数为 0 或为奇数，则无解返回 0；否则返回累计结果。

## 正确性说明

- 每个合法分段必须有且仅有 2 个座位；因此座位总数若为 0 或奇数，必无解。
- 对于已完成的段，其右端座位与下一段左端座位之间的任意位置都可放隔板，位置数量正是两座位下标差。累乘所有段间可选位置即枚举了所有合法切分方式。
- 计算过程中仅在段间乘以可行位置数，不会遗漏或重复计数，因此结果正确。

## 复杂度分析

- 时间复杂度：O(n)，单次扫描。
- 空间复杂度：O(1)。

## 关键代码片段

```cpp
int numberOfWays(string corridor) {
    constexpr int MOD = 1e9 + 7;
    long long ans = 1;
    int cnt_s = 0, last_s = 0;
    for (int i = 0; i < corridor.size(); ++i) {
        if (corridor[i] == 'S') {
            ++cnt_s;
            if (cnt_s >= 3 && (cnt_s & 1)) {
                ans = (ans * (i - last_s)) % MOD; // 段间可插隔板的位置数
            }
            last_s = i;
        }
    }
    if (cnt_s == 0 || (cnt_s & 1)) return 0;
    return ans;
}
```
