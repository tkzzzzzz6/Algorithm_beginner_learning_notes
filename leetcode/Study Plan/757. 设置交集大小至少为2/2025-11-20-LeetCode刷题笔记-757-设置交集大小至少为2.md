---
title: 2025-11-20-LeetCode刷题笔记-757-设置交集大小至少为2
date: 2025-11-20
tags:
  - 算法学习
  - LeetCode
  - 贪心算法
  - 区间问题
---

# 题目信息
- 平台：LeetCode
- 题目：757. 设置交集大小至少为2
- 难度：Hard
- 题目链接：[Set Intersection Size At Least Two](https://leetcode.cn/problems/set-intersection-size-at-least-two/description/?envType=daily-question&envId=2025-11-20)

---

## 题目描述
> 给定一个由若干区间组成的数组 `intervals`，其中 `intervals[i] = [startᵢ, endᵢ]`。要求构造一个集合 S，使得对于每个区间 `[startᵢ, endᵢ]`，S 与该区间的交集大小至少为 2。返回这样的集合 S 的最小可能大小。

**示例 1：**
```
输入：intervals = [[1,3],[1,4],[2,5],[3,5]]
输出：3
解释：考虑集合 S = {2, 3, 4}，S 与每个区间都有至少 2 个元素的交集。
```

**示例 2：**
```
输入：intervals = [[1,2],[2,3],[2,4],[4,5]]
输出：5
解释：需要集合 S = {1, 2, 3, 4, 5}
```

**约束条件：**
- 1 <= intervals.length <= 3000
- intervals[i].length == 2
- 0 <= startᵢ < endᵢ <= 10⁸

---

## 初步思路
1. 这是一个经典的区间贪心问题，需要选择最少的点覆盖所有区间
2. 与普通的区间覆盖问题不同，这里每个区间需要至少 2 个点
3. 贪心策略：按区间右端点排序，优先选择靠右的点
4. 使用栈来维护已选择的点所形成的区间，方便计算交集

---

## 算法分析
- **核心思想**：贪心算法 + 区间合并 + 栈
- **关键技巧**：
  1. 按右端点对区间排序，保证贪心选择的正确性
  2. 使用栈维护已选点形成的闭区间 [l, r]，以及从起始到当前的点数总和 s
  3. 对于每个新区间，通过二分查找定位与栈中哪个区间相交
  4. 计算需要新增的点数 d = 2 - 已有交集点数
  5. 贪心地从右端点开始填充新点，必要时合并栈顶区间
- **时间复杂度**：O(n log n)，主要是排序和二分查找
- **空间复杂度**：O(n)，栈空间

---

## 代码实现（Go）

### 解法一：优化的贪心 + 栈
```go
func intersectionSizeTwo(intervals [][]int) int {
    // 按右端点排序
    slices.SortFunc(intervals, func(a, b []int) int {
        return a[1] - b[1]
    })
    
    // 栈中保存闭区间左右端点，栈底到栈顶的区间长度的和
    type tuple struct{ l, r, s int }
    st := []tuple{{-2, -2, 0}} // 哨兵，保证不和任何区间相交
    
    for _, p := range intervals {
        start, end := p[0], p[1]
        // 二分查找：找到栈中第一个左端点 >= start 的区间
        i := sort.Search(len(st), func(i int) bool { 
            return st[i].l >= start 
        }) - 1
        
        // 计算需要新增的点数
        d := 2 - (st[len(st)-1].s - st[i].s) // 当前区间已有的交集点数
        if start <= st[i].r { // start 在区间 st[i] 内
            d -= st[i].r - start + 1 // 去掉 [start, st[i].r] 中的点
        }
        
        if d <= 0 {
            continue // 已有至少 2 个交集点，无需新增
        }
        
        // 贪心地从右端点填充 d 个点
        // 如果栈顶区间能被完全包含，就合并它
        for end-st[len(st)-1].r <= d {
            top := st[len(st)-1]
            st = st[:len(st)-1]
            d += top.r - top.l + 1 // 合并区间，增加可填充的空间
        }
        
        // 在 [end-d+1, end] 中填充 d 个点
        st = append(st, tuple{end - d + 1, end, st[len(st)-1].s + d})
    }
    
    return st[len(st)-1].s
}
```

### 解法二：简化版（清晰易懂）
```go
func intersectionSizeTwo(intervals [][]int) int {
    slices.SortFunc(intervals, func(a, b []int) int { 
        return a[1] - b[1] 
    })
    
    type tuple struct{ l, r, s int }
    st := []tuple{{-2, -2, 0}} // 哨兵
    
    for _, p := range intervals {
        start, end := p[0], p[1]
        i := sort.Search(len(st), func(i int) bool {
            return st[i].l >= start
        }) - 1
        
        d := 2 - (st[len(st)-1].s - st[i].s)
        if start <= st[i].r {
            d -= st[i].r - start + 1
        }
        
        if d <= 0 {
            continue
        }
        
        for end-st[len(st)-1].r <= d {
            top := st[len(st)-1]
            st = st[:len(st)-1]
            d += top.r - top.l + 1
        }
        
        st = append(st, tuple{end - d + 1, end, st[len(st)-1].s + d})
    }
    
    return st[len(st)-1].s
}
```

---

## 算法详解

### 1. 为什么按右端点排序？
按右端点排序后，当处理区间 i 时，所有右端点 ≤ intervals[i].end 的区间都已处理完毕。这样可以保证贪心选择的正确性：尽量选择靠右的点，这些点更有可能与后续区间产生交集。

### 2. 栈的作用
栈中每个元素 `tuple{l, r, s}` 表示：
- `[l, r]`：已选点形成的一个闭区间
- `s`：从开始到当前栈顶，累计选择的点数

栈的性质：栈中区间互不相交，且按左端点递增排列。

### 3. 为什么要合并区间？
当需要填充 d 个点，且栈顶区间 `[l, r]` 完全可以被新区间 `[end-d+1, end]` 覆盖时（即 `end - r <= d`），说明栈顶区间的点可以被"吸收"进新区间，这样可以减少区间数量，简化后续处理。

### 4. 二分查找的目的
找到栈中第一个与当前区间 `[start, end]` 相交的区间位置，用于计算已有的交集点数。

---

## 测试用例
| 输入 | 输出 | 说明 |
|------|------|------|
| [[1,3],[1,4],[2,5],[3,5]] | 3 | 选择 {2, 3, 4} |
| [[1,2],[2,3],[2,4],[4,5]] | 5 | 选择 {1, 2, 3, 4, 5} |
| [[1,3],[3,7],[5,7],[7,8]] | 5 | 复杂的交集情况 |

---

## 复杂度分析
- **时间复杂度**：O(n log n)
  - 排序：O(n log n)
  - 每个区间处理：O(log n)（二分查找）+ O(1)（均摊，因为每个元素最多入栈出栈一次）
- **空间复杂度**：O(n)
  - 栈的空间：最坏情况下 O(n)
  - 排序空间：O(log n)

---

## 总结与反思
1. **贪心策略的正确性**：本题的贪心策略是按右端点排序后，尽量选择靠右的点。这样可以最大化点的利用率，使后续区间更可能与已选点产生交集。

2. **栈的巧妙运用**：使用栈维护已选点形成的区间，不仅方便计算交集，还能通过合并区间来优化存储和计算。

3. **区间问题的通用技巧**：
   - 按端点排序是区间问题的常见技巧
   - 贪心选择通常与排序策略相关
   - 维护有序的区间集合时，考虑使用栈或其他数据结构

4. **易错点**：
   - 二分查找的边界处理（需要 -1）
   - 哨兵的设置（避免特判空栈）
   - 区间合并的条件判断

5. **优化空间**：
   - 可以考虑直接维护点集而不是区间，但会增加查找时间
   - 对于特殊数据（如区间长度都很小），可以使用不同的策略

---

## 相关题目
- LeetCode 452. 用最少数量的箭引爆气球
- LeetCode 435. 无重叠区间
- LeetCode 763. 划分字母区间
- LeetCode 56. 合并区间

---

